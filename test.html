<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Beyond All Reason - Map Popularity Stats for the Last 60 Days</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <style>
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
    }
    th {
      background-color: #f2f2f2;
    }
    .loading-message {
      font-size: 1.2em;
      color: #555;
      text-align: center;
      margin-top: 20px;
    }
    .filter-section {
      margin-bottom: 20px;
    }
    .total-matches-column {
      background-color: #ffeeba;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Beyond All Reason - Map Popularity Stats for the Last 60 Days</h1>
<div><a href=https://github.com/Dazazzell/barmaps/>https://github.com/Dazazzell/barmaps/</a><br><div>
<div><a href=lobbycommands.html>BAR Lobby commands dump</a><br></div>
<div>----<br></div>
  <div>&nbsp<br></div>
  <div class="filter-section">
    <label for="gameTypeSelect">Filter by Game Type:</label>
    <select id="gameTypeSelect">
      <option value="all" selected>All Game Types</option>
    </select>
  </div>

  <div id="loadingMessage" class="loading-message">Slowly loading and processing data, please wait...</div>

  <div id="lastMatchDate" class="loading-message" style="display: none;"></div>
  
  <table id="mapPlayerTable" style="display:none;">
    <thead>
      <tr>
        <th>Map</th>
        <th class="total-matches-column">Number of Matches</th>
        <!-- Player count columns will be added dynamically -->
      </tr>
    </thead>
    <tbody>
      <!-- Data rows will be inserted here -->
    </tbody>
  </table>

<script>
    let aggregatedData = {};
    let filteredGameType = 'all';

    async function fetchAndParseCSV(url, callback) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Network response was not ok: ${response.statusText}`);
        }

        const arrayBuffer = await response.arrayBuffer();
        const decompressed = pako.ungzip(new Uint8Array(arrayBuffer), { to: 'string' });

        Papa.parse(decompressed, {
          header: true,
          step: (row) => {
            callback(row.data);  // Process each row as it comes
          },
          error: (error) => {
            console.error('Error parsing CSV:', error);
            document.body.insertAdjacentHTML('beforeend', `<p>Error parsing CSV: ${error.message}</p>`);
          }
        });
      } catch (error) {
        console.error('Error fetching or processing data:', error);
        document.body.insertAdjacentHTML('beforeend', `<p>Error fetching or processing data: ${error.message}</p>`);
      }
    }

    function filterDataByDate(gameDate) {
      const sixtyDaysAgo = new Date();
      sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);
      return new Date(gameDate) >= sixtyDaysAgo;
    }

    function aggregateData(matches, players) {
      const matchPlayerMap = {};

      players.forEach(player => {
        const matchId = player.match_id;
        if (!matchPlayerMap[matchId]) {
          matchPlayerMap[matchId] = { map: null, playerCount: 0 };
        }
        matchPlayerMap[matchId].playerCount++;
      });

      matches.forEach(match => {
        const matchId = match.match_id;
        if (matchPlayerMap[matchId]) {
          matchPlayerMap[matchId].map = match.map;
        }
      });

      return matchPlayerMap;
    }

    function aggregateAndFilterRow(matchRow) {
      // Filter by date and game type
      if (!filterDataByDate(matchRow.start_time)) return;
      if (filteredGameType !== 'all' && matchRow.game_type !== filteredGameType) return;

      const map = matchRow.map;
      const matchId = matchRow.match_id;
      
      if (!aggregatedData[map]) {
        aggregatedData[map] = { totalMatches: 0, playerCounts: {} };
      }

      aggregatedData[map].totalMatches++;
      // Track players separately
      aggregatedData[map].playerCounts[matchId] = aggregatedData[map].playerCounts[matchId] || 0;
    }

    function populateGameTypeSelect(matches) {
      const gameTypes = new Set(matches.map(match => match.game_type));
      const gameTypeSelect = document.getElementById('gameTypeSelect');
      
      gameTypes.forEach(gameType => {
        const option = document.createElement('option');
        option.value = gameType;
        option.textContent = gameType;
        gameTypeSelect.appendChild(option);
      });
    }

    function displayTable() {
      const tableBody = document.getElementById('mapPlayerTable').getElementsByTagName('tbody')[0];
      const tableHead = document.getElementById('mapPlayerTable').getElementsByTagName('thead')[0];

      // Sort player counts in descending order
      const playerCounts = new Set(Object.keys(aggregatedData).map(map => Object.keys(aggregatedData[map].playerCounts).length));
      playerCounts.sort((a, b) => b - a);

      tableHead.innerHTML = `<tr>
        <th>Map</th>
        <th class="total-matches-column">Number of Matches</th>
        ${playerCounts.map(count => `<th>Games with ${count} Players</th>`).join('')}
      </tr>`;

      tableBody.innerHTML = ''; // Clear any existing rows

      // Convert the aggregatedData object to an array of [map, count] pairs
      const countArray = Object.entries(aggregatedData);

      // Sort the array by totalMatches in descending order
      countArray.sort((a, b) => b[1].totalMatches - a[1].totalMatches);

      // Create table rows for each map, match count, and player count breakdown
      countArray.forEach(([map, counts]) => {
        const row = document.createElement('tr');
        const mapCell = document.createElement('td');
        const matchesCell = document.createElement('td');

        mapCell.textContent = map;
        matchesCell.textContent = counts.totalMatches;
        matchesCell.classList.add('total-matches-column'); // Apply custom class for styling

        row.appendChild(mapCell);
        row.appendChild(matchesCell);

        // Add cells for each player count, in descending order
        playerCounts.forEach(count => {
          const cell = document.createElement('td');
          cell.textContent = counts.playerCounts[count] || 0;
          row.appendChild(cell);
        });

        tableBody.appendChild(row);
      });

      // Hide loading message and show the table
      document.getElementById('loadingMessage').style.display = 'none';
      document.getElementById('mapPlayerTable').style.display = 'table';
    }

    async function fetchData() {
      document.getElementById('loadingMessage').style.display = 'block'; // Show loading message
      document.getElementById('mapPlayerTable').style.display = 'none'; // Hide table initially
      document.getElementById('lastMatchDate').style.display = 'none'; // Hide last match date initially

      fetchAndParseCSV('https://data-marts.beyondallreason.dev/matches.csv.gz', (row) => {
        aggregateAndFilterRow(row);
      });

      fetchAndParseCSV('https://data-marts.beyondallreason.dev/match_players.csv.gz', (row) => {
        aggregateAndFilterRow(row);
        displayTable();  // Update the table after both CSVs are processed
      });
    }

    document.getElementById('gameTypeSelect').addEventListener('change', function() {
      filteredGameType = this.value;
      fetchData(); // Re-fetch and aggregate data when game type changes
    });

    fetchData();  // Initial load
</script>
  
</body>
</html>
